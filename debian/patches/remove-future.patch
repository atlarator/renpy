--- a/module/generate_styles.py
+++ b/module/generate_styles.py
@@ -19,13 +19,6 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-from __future__ import print_function, unicode_literals, division, absolute_import
-
-from future import standard_library
-standard_library.install_aliases()
-
-from builtins import str
-
 import collections
 import os
 
--- a/launcher/game/choose_theme.rpy
+++ b/launcher/game/choose_theme.rpy
@@ -24,7 +24,6 @@
     import codecs
     import re
     import sys
-    import future.utils
 
     def theme_names():
         """
@@ -98,7 +97,7 @@
             return
 
         renpy.style.restore(style_backup)
-        future.utils.exec_(theme_data.THEME[theme][scheme], globals(), globals())
+        exec(theme_data.THEME[theme][scheme], globals(), globals())
 
         # Rebuild the style cache.
         renpy.style.rebuild(False)
--- a/module/setup.py
+++ b/module/setup.py
@@ -21,15 +21,11 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-from __future__ import print_function
-
 import platform
 import sys
 import os
 import subprocess
 
-import future
-
 # Change to the directory containing this file.
 BASE = os.path.abspath(os.path.dirname(sys.argv[0]))
 os.chdir(BASE)
--- a/renpy/audio/audio.py
+++ b/renpy/audio/audio.py
@@ -24,12 +24,6 @@
 # Invariants: The periodic callback assumes pcm_ok. If we don't have
 # at least pcm_ok, we have no sound whatsoever.
 
-from __future__ import division, absolute_import, with_statement, print_function, unicode_literals
-from renpy.compat import PY2, basestring, bchr, bord, chr, open, pystr, range, round, str, tobytes, unicode # *
-
-
-from future.utils import raise_
-
 import time
 import pygame_sdl2 # @UnusedImport
 import os
@@ -1245,7 +1239,7 @@
             exc = periodic_exc
             periodic_exc = None
 
-            raise_(exc[0], exc[1], exc[2])
+            raise exc
 
         run_periodic = True
         periodic_condition.notify()
--- a/renpy/common/00updater.rpy
+++ b/renpy/common/00updater.rpy
@@ -41,7 +41,6 @@
     import zlib
     import codecs
     import io
-    import future.utils
 
     def urlopen(url):
         import requests
@@ -1057,6 +1056,7 @@
                     future.utils.exec_(monkeypatch, globals(), globals())
             elif verified and "monkeypatch" in self.updates:
                 future.utils.exec_(self.updates["monkeypatch"], globals(), globals())
+                exec(self.updates["monkeypatch"], globals(), globals())
 
         def add_dlc_state(self, name):
 
--- a/renpy/compat/__init__.py
+++ b/renpy/compat/__init__.py
@@ -1,4 +1,4 @@
-# Copyright 2004-2024 Tom Rothamel <pytom@bishoujo.us>
+# Copyright 2004-2023 Tom Rothamel <pytom@bishoujo.us>
 #
 # Permission is hereby granted, free of charge, to any person
 # obtaining a copy of this software and associated documentation files
@@ -19,201 +19,31 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-"""
-This module is defined to allow us to program in Python 2 with a high degree
-of compatibility with Python 3, and vice versa. It's intended to be invoked
-with the following preamble::
-
-    from __future__ import division, absolute_import, with_statement, print_function, unicode_literals
-    from renpy.compat import *
-
-Right now, it does the following things:
-
-* Sets up aliases for Python 3 module moves, allowing the Python 3 names
-  to be used in Python 2.
-
-* Defines PY2 in the current context, to make Python 2 conditional.
-
-* Aliases pickle to cPickle on Python 3, to support Python 2 code
-  choosing between the implementations, where the choice is meaningful
-
-* Replaces open with a function that mimics the Python 3 behavior, of
-  opening files in a unicode-friendly mode by default.
-
-* Redefines the text types, so that str is always the unicode type, and
-  basestring is the list of string types available on the system.
-
-* Exposes bchr, bord, and tobytes from future.utils.
-
-* Changes the meaning of the .items(), .keys(), and .values() methods of
-  dict to return views, rather than lists. (This is a fairly major change,
-  and so is only available when with_statement and division are both
-  imported.
-
-* Aliases xrange to range on Python 2.
-
-* Changes the behavior of TextIOWrapper.write so that bytes strings are promoted
-  to unicode strings before being written.
-"""
-
-from __future__ import division, absolute_import, with_statement, print_function, unicode_literals
-
-import future.standard_library
-import future.utils
 import builtins
 
-import io
-import sys
-import operator
-
-python_open = open
-
-################################################################################
-# Alias the Python 3 standard library.
-
-future.standard_library.install_aliases()
-
-################################################################################
-# Determine if this is Python2.
-
-PY2 = future.utils.PY2
-
-################################################################################
-# Make open mimic Python 3.
-
-if PY2:
-    open = io.open
-    import re
-    re.Pattern = re._pattern_type # type:ignore
-else:
-    open = builtins.open
-
-
-def compat_open(*args, **kwargs):
-    if (sys._getframe(1).f_code.co_flags & 0xa000) == 0xa000:
-        return open(*args, **kwargs)
-    else:
-        return python_open(*args, **kwargs)
-
-
-################################################################################
-# Make strict use surrogateescape error handling on PY2.
-
-import codecs
-
-strict_error = codecs.lookup_error("strict")
-codecs.register_error("python_strict", strict_error)
-
-if PY2:
-    surrogateescape_error = codecs.lookup_error("surrogateescape")
-    codecs.register_error("strict", surrogateescape_error)
-
-import renpy
-renpy.update_path()
-
-################################################################################
-# String (text and binary) types and functions.
-
-basestring = future.utils.string_types
+PY2 = False
+basestring = str
 pystr = str
-unicode = future.utils.text_type
-
-# This tries to help pylance get the types right.
-str = builtins.str; globals()["str"] = future.utils.text_type
-
-
-bord = future.utils.bord
-
-if PY2:
-    bchr = chr # type: ignore
-else:
-    def bchr(i): # type: (int) -> bytes
-        return bytes([i])
-tobytes = future.utils.tobytes
-
-from future.builtins import chr
-
-################################################################################
-# Dictionary views.
-
-# The try block solves a chicken-and-egg problem when dictviews is not
-# compiled yet, as part of the Ren'Py build process.
-
-def add_attribute(obj, name, value):
-    pass
-
-if PY2:
-    try:
-        from renpy.compat.dictviews import add_attribute
-    except ImportError:
-        print("Could not import renpy.compat.dictviews.", file=sys.stderr)
-
-
-################################################################################
-# Range.
-
-if PY2:
-    range = xrange # type: ignore
-else:
-    range = builtins.range
-
-################################################################################
-# Round.
-
+unicode = str
+open = builtins.open
+str = builtins.str
+range = builtins.range
 round = builtins.round
+chr = builtins.chr
 
-################################################################################
-# Allow TextIOWrapper to take utf8-bytes.
+def bchr(i):
+    return bytes([i])
 
-if PY2:
+def bord(s):
+    return s
 
-    import types
-
-    # io.TextIOWrapper._write = io.TextIOWrapper.write
-
-    def text_write(self, s):
-        if isinstance(s, bytes):
-            s = s.decode("utf-8", "surrogateescape")
-        return self._write(s)
-
-    add_attribute(io.TextIOWrapper, "_write", io.TextIOWrapper.write)
-    add_attribute(io.TextIOWrapper, "write", types.MethodType(text_write, None, io.TextIOWrapper)) # type: ignore
-
-################################################################################
-# Chance the default for subprocess.Popen.
-if PY2:
-    import subprocess
-    if hasattr(subprocess, 'Popen'):  # Web2 does not have subprocess.Popen
-        class Popen(subprocess.Popen):
-            def __init__(self, *args, **kwargs):
-                if ("stdout" not in kwargs) and ("stderr" not in kwargs) and ("stdin" not in kwargs):
-                    kwargs.setdefault("close_fds", True)
-                super(Popen, self).__init__(*args, **kwargs)
-
-        subprocess.Popen = Popen
-
-################################################################################
-# Intern
-
-if PY2:
-    intern_cache = {}
-
-    def intern(s):
-        return intern_cache.setdefault(s, s)
-
-    sys.intern = intern
-
-################################################################################
-# Export functions.
+def tobytes(s):
+    if isinstance(s, bytes):
+        return s
+    elif isinstance(s, str):
+        return s.encode('latin-1')
+    else:
+        return bytes(s)
 
 __all__ = [ "PY2", "open", "basestring", "str", "pystr", "range",
             "round", "bord", "bchr", "tobytes", "chr", "unicode", ]
-
-if PY2:
-    __all__ = [ bytes(i) for i in __all__ ] # type: ignore
-
-
-# Generated by scripts/relative_imports.py, do not edit below this line.
-if 1 == 0:
-    from . import fixes
-    from . import pickle
--- a/renpy/execution.py
+++ b/renpy/execution.py
@@ -22,11 +22,6 @@
 # This file contains code responsible for managing the execution of a
 # renpy object, as well as the context object.
 
-from __future__ import division, absolute_import, with_statement, print_function, unicode_literals
-from renpy.compat import PY2, basestring, bchr, bord, chr, open, pystr, range, round, str, tobytes, unicode # *
-
-from future.utils import reraise
-
 import sys
 import time
 
@@ -630,8 +625,8 @@
                                 raise
                     except renpy.game.CONTROL_EXCEPTIONS as ce:
                         raise ce
-                    except Exception:
-                        reraise(exc_info[0], exc_info[1], exc_info[2])
+                    except Exception as e:
+                        raise e
 
                 node = self.next_node
 
--- a/renpy/loadsave.py
+++ b/renpy/loadsave.py
@@ -21,10 +21,26 @@
 
 # This file contains functions that load and save the game state.
 
-from __future__ import division, absolute_import, with_statement, print_function, unicode_literals
-from renpy.compat import PY2, basestring, bchr, bord, chr, open, pystr, range, round, str, tobytes, unicode # *
+def reraise(value=None, tp=None):
+    if isinstance(tp, BaseException):
+        if value is not None:
+            raise TypeError("instance exception may not have a separate value")
+        exc = tp
+    elif isinstance(tp, type) and not issubclass(tp, BaseException):
+        raise TypeError("class must derive from BaseException, not %s" % tp.__name__)
+    else:
+        if isinstance(value, tp):
+            exc = value
+        elif isinstance(value, tuple):
+            exc = tp(*value)
+        elif value is None:
+            exc = tp()
+        else:
+            exc = tp(value)
 
-from future.utils import reraise
+    if exc.__traceback__ is not tp:
+        raise exc.with_traceback(tp)
+    raise exc
 
 from typing import Optional
 
@@ -68,7 +84,7 @@
         if isinstance(o, (int, float, type(None), types.ModuleType, type)):
             o_repr = repr(o)
 
-        elif isinstance(o, basestring):
+        elif isinstance(o, str):
             if len(o) <= 80:
                 o_repr = repr(o)
             else:
@@ -81,17 +97,10 @@
             o_repr = "<" + o.__class__.__name__ + ">"
 
         elif isinstance(o, types.MethodType):
-
-            if PY2:
-                o_repr = "<method {0}.{1}>".format(o.__self__.__class__.__name__, o.__func__.__name__) # type: ignore
-            else:
-                o_repr = "<method {0}.{1}>".format(o.__self__.__class__.__name__, o.__name__)
+            o_repr = "<method {0}.{1}>".format(o.__self__.__class__.__name__, o.__name__)
 
         elif isinstance(o, types.FunctionType):
-            if PY2:
-                name = o.__name__
-            else:
-                name = o.__qualname__ or o.__name__
+            name = o.__qualname__ or o.__name__
 
             o_repr = o.__module__ + '.' + name
 
@@ -135,7 +144,7 @@
                 reduction = [ ]
                 o_repr_cache[ido] = "BAD REDUCTION " + o_repr
 
-            if isinstance(reduction, basestring):
+            if isinstance(reduction, str):
                 o_repr_cache[ido] = o.__module__ + '.' + reduction
                 size = 1
 
